# FinanceTracker — Модуль учёта финансов

## Описание проекта по ДЗ №2

Данный проект представляет собой консольное приложение для учёта личных финансов, разработанное в рамках домашнего задания №2 по дисциплине «Конструирование программного обеспечения».

Система реализует требования заказчика aka "ВШЭ-Банка" к модулю финансового учёта и предоставляет пользователю следующие возможности
- Управление счетами, категориями и операциями (доходы/расходы).
- Проведение аналитики (разница доходов и расходов, группировка по категориям, детализированный отчёт по операциям).
- Импорт и экспорт данных в формате JSON.
- Автоматический и ручной пересчёт баланса.
- Измерение времени выполнения пользовательских сценариев.

Архитектура проекта построена в соответствии с принципами **Чистой Архитектуры (Clean Architecture)**, **SOLID**, **GRASP**, а также с применением паттернов проектирования **GoF**.

---

## Архитектура

Решение реализовано в строгом соответствии с **Правилом Зависимостей (Dependency Rule)** из Чистой Архитектуры. Зависимости направлены исключительно от внешних, нестабильных слоёв к внутренним, стабильным.

- **`FinanceTracker.Core`** — **Ядро Домена**. Содержит самые стабильные и высокоуровневые правила, такие как доменные сущности (`BankAccount`, `Category`, `Operation`) и интерфейсы репозиториев (`IBankAccountRepository` и др.). Не имеет зависимостей от других проектов.

- **`FinanceTracker.Application`** — **Слой Сценариев (Use Cases)**. Содержит бизнес-логику приложения, реализуемую через сервисы (`IAccountService`, `IAnalyticsService`), команды (`ICommand<T>`) и декораторы. Зависит только от `Core`.

- **`FinanceTracker.Infrastructure`** — **Слой Инфраструктуры**. Содержит реализации "технических деталей", таких как репозитории для работы с данными (`InMemory...Repository`) и логику импорта/экспорта (`JsonHandler`). Зависит только от `Core`.

- **`FinanceTracker.ConsoleApp`** — **Слой Представления (UI)**. Отвечает за взаимодействие с пользователем через консоль. Является **корнем композиции (Composition Root)**, где все зависимости собираются воедино с помощью DI-контейнера.

- **`FinanceTracker.Tests`** — **Слой Тестирования**. Содержит юнит-тесты для всех слоёв бизнес-логики, обеспечивая высокое покрытие и уверенность в корректности работы системы.

---

## Реализованные паттерны GoF

В рамках ДЗ №2 было реализовано 5 паттернов проектирования:

| № | Паттерн | Реализация | Обоснование |
|---|---|---|---|
| 1 | **Фасад** | `IAccountService`, `IAnalyticsService` и др. | Инкапсулирует сложную логику работы с репозиториями и сущностями в простые, высокоуровневые интерфейсы. UI-слой работает с простым фасадом, не зная о деталях реализации. |
| 2 | **Команда** | `ICommand<T>`, `CreateAccountCommand` и др. | Инкапсулирует каждый пользовательский сценарий (например, "создать счёт") в отдельный объект. Это позволяет передавать операции как параметры и легко их декорировать. |
| 3 | **Декоратор** | `TimedCommandDecorator<T>` | "Оборачивает" любую команду для добавления новой функциональности (измерение времени) без изменения исходного кода команды, что полностью соответствует Принципу Открытости/Закрытости. |
| 4 | **Шаблонный метод** | `JsonHandler` и его методы `Export`/`Import` | Задаёт "скелет" алгоритма: получить все данные из репозиториев -> сериализовать в JSON -> записать в файл. Конкретная реализация (например, выбор формата) может быть вынесена в подклассы. |
| 5 | **Фабрика** | Конструкторы сущностей (`BankAccount`, `Category`) | Хотя формальной фабрики нет, её роль выполняют конструкторы, которые являются единственной точкой создания валидных объектов. Они инкапсулируют логику проверки (например, имя не может быть пустым), предотвращая создание невалидных сущностей в системе. |

---

## Применение принципов SOLID

### S — Принцип единственной ответственности (SRP)
*Класс должен иметь только одну причину для изменения.*

- **На уровне классов**
    - `AccountService` отвечает только за бизнес-логику управления счетами.
    - `JsonHandler` отвечает только за сериализацию/десериализацию данных в JSON.
    - `ConsoleUI` отвечает только за отображение данных в консоли и приём ввода.
    - `TimedCommandDecorator` отвечает только за измерение времени.
- **На уровне слоёв**
    - Каждый проект имеет чёткую зону ответственности, что предотвращает "размазывание" логики по системе.

### O — Принцип открытости/закрытости (OCP)
*Программные сущности должны быть открыты для расширения, но закрыты для изменения.*

- **Пример**
    - Чтобы добавить новый формат экспорта (например, в CSV), не нужно изменять существующий `JsonHandler`. Достаточно создать новый класс `CsvHandler`, реализующий тот же интерфейс `IFileImportExportService`, и зарегистрировать его в DI-контейнере. `ConsoleUI` и сервисы при этом не изменятся.

### L — Принцип подстановки Лисков (LSP)
*Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.*

- **Пример**
    - Метод `ExecuteTimedCommand` принимает базовый интерфейс `ICommand<T>`. Мы можем передать в него любой конкретный класс команды (`CreateAccountCommand`, `AddOperationCommand`), и логика декоратора (`TimedCommandDecorator`) не нарушится, так как все реализации `ICommand<T>` соблюдают контракт базового интерфейса.

### I — Принцип разделения интерфейсов (ISP)
*Клиенты не должны быть вынуждены зависеть от методов, которые они не используют.*

Интерфейсы сервисов максимально атомарны и сфокусированы на конкретной задаче.
- **Пример**
    - `ConsoleUI` для отображения статистики зависит только от `IAnalyticsService` и `IAccountService`, а не от одного "толстого" интерфейса `IApplicationService`, в котором были бы и методы для импорта/экспорта, которые ему не нужны.

### D — Принцип инверсии зависимостей (DIP)
*Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба должны зависеть от абстракций.*

Это фундаментальный принцип, на котором построена вся архитектура.
- **Пример 1 (Между слоями)**
    - `Application` слой (`AccountService`) не знает о `Infrastructure` слое (`InMemoryBankAccountRepository`). Вместо этого оба слоя зависят от абстракции `IBankAccountRepository` из `Core`.
- **Пример 2 (Внутри `ConsoleApp`)**
    - `ConsoleUI` зависит от абстракций `IAccountService`, `IAnalyticsService`, а не от их конкретных реализаций. Это позволяет легко подменять реализации в DI-контейнере, не меняя код UI.

---

## Применение принципов GRASP

Наряду с SOLID, архитектура опирается на GRASP-паттерны для грамотного распределения ответственностей.

- **Information Expert (Информационный эксперт)**
    - *Ответственность назначается тому, кто владеет нужной информацией.*
    - **Пример:** `AnalyticsService` является экспертом по вычислению общей статистики. Он не хранит данные сам, но имеет доступ ко всем репозиториям (`IOperationRepository`, `IAccountRepository`), чтобы собрать необходимую информацию и произвести расчеты. Класс `BankAccount`, в свою очередь, является экспертом по своему собственному состоянию (имени и текущему балансу).

- **Creator (Создатель)**
    - *Класс `B` должен создавать класс `A`, если `B` агрегирует `A` или тесно использует `A`.*
    - **Пример:** `AccountService` отвечает за создание объектов `BankAccount`. Он получает необходимые данные (имя счёта) от UI и является тем компонентом, который "тесно использует" и управляет жизненным циклом счетов.

- **Controller (Контроллер)**
    - *Ответственность за обработку системных событий назначается классу, представляющему сценарий использования.*
    - **Пример:** `ConsoleUI` выполняет роль Контроллера. Он не реализует бизнес-логику, а принимает ввод от пользователя (системное событие "выбран пункт меню") и делегирует выполнение задачи соответствующему сервису или команде (`IAccountService` или `AddOperationCommand`).

- **High Cohesion (Высокое зацепление) & Low Coupling (Низкая связанность)**
    - *Классы должны быть сфокусированы на одной задаче (High Cohesion) и иметь минимум зависимостей от других (Low Coupling).*
    - **Пример:** Вся архитектура является демонстрацией этих принципов. `JsonHandler` имеет высокую связность, так как занимается только работой с JSON. Низкая связанность достигается за счёт зависимостей от абстракций (`Core`), что позволяет слоям `Application` и `Infrastructure` ничего не знать друг о друге.

- **Pure Fabrication (Чистая выдумка)**
    - *Создание искусственного класса для решения задачи, которая не вписывается в доменную модель.*
    - **Пример:** `TimedCommandDecorator` является "чистой выдумкой". В домене финансов нет понятия "измеритель времени". Этот класс был создан искусственно, чтобы решить техническую задачу (требование 4a ДЗ) и отделить её от основной бизнес-логики команд.

---

## Тестирование

Проект содержит полный набор юнит- и интеграционных тестов для всех ключевых компонентов, обеспечивая **высокое покрытие кода (>75%)** для слоёв бизнес-логики и инфраструктуры.
- **Юнит-тесты** (с использованием Moq) проверяют сервисы и логику в изоляции.
- **Интеграционные тесты** проверяют корректность работы `InMemory` репозиториев.
- Слой UI (`ConsoleApp`) намеренно **не покрывается** юнит-тестами, так как его логика минимальна, а тестирование консольного вывода является неэффективным.

Все тесты написаны в стиле AAA (Arrange–Act–Assert), не зависят от окружения и покрывают как успешные сценарии, так и обработку ошибок (например, импорт "битого" JSON).

---

## Инструкция по запуску

1. Убедитесь, что установлен .NET 8 SDK.
2. Выполните команду для восстановления зависимостей в корневой папке проекта:
   ```bash
   dotnet restore
   ```
3. Для запуска приложения выполните команду:
   ```bash
   dotnet run --project FinanceTracker.ConsoleApp
   ```
4. Для запуска тестов выполните команду:
   ```bash
   dotnet test
   ```
---

### Реализовано с учётом информации из данных источников:
- [Чистая Архитектура — краткая выжимка](https://habr.com/ru/companies/otus/articles/732178/)
- [Принципы SOLID: интуитивно ясное объяснение](https://habr.com/ru/companies/productivity_inside/articles/505430/)
- [Мартин Фаулер о Внедрении Зависимостей (Dependency Injection)](https://martinfowler.com/articles/injection.html)
- [Паттерны проектирования GoF простыми словами](https://refactoring.guru/ru/design-patterns)
- [Полномерное разъяснение GoF паттернов](https://bool.dev/blog/detail/gof-design-patterns)
- [Основы юнит-тестирования в .NET с xUnit и Moq](https://learn.microsoft.com/ru-ru/dotnet/core/testing/unit-testing-with-dotnet-test)

### Прахов Данил, БПИ246
